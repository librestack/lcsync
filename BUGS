-------------------------------------------------------------------------------
0000-0066 intermittent "timeout - recv" when run as make cap - passes when run
separately
-------------------------------------------------------------------------------
Intermittent memory leak when quitting lcsync in mld server mode. Something not
getting free()'d by signal handler.

==9986== 
==9986== HEAP SUMMARY:
==9986==     in use at exit: 240 bytes in 4 blocks
==9986==   total heap usage: 121 allocs, 117 frees, 268,548,714 bytes allocated
==9986== 
==9986== 120 (88 direct, 32 indirect) bytes in 1 blocks are definitely lost in loss record 3 of 4
==9986==    at 0x483AB86: calloc (vg_replace_malloc.c:760)
==9986==    by 0x10B83A: job_new (job.c:43)
==9986==    by 0x10B999: job_push_new (job.c:74)
==9986==    by 0x10E962: mld_start (mld.c:745)
==9986==    by 0x113856: net_send_data (net.c:829)
==9986==    by 0x113B1E: net_send (net.c:880)
==9986==    by 0x10A792: main (lcsync.c:28)
==9986== 
==9986== 120 (88 direct, 32 indirect) bytes in 1 blocks are definitely lost in loss record 4 of 4
==9986==    at 0x483AB86: calloc (vg_replace_malloc.c:760)
==9986==    by 0x10B83A: job_new (job.c:43)
==9986==    by 0x10B999: job_push_new (job.c:74)
==9986==    by 0x10C795: mld_timer_ticker (mld.c:140)
==9986==    by 0x10C6AF: mld_timer_job (mld.c:123)
==9986==    by 0x10B9E8: job_seek (job.c:84)
==9986==    by 0x49BCF5D: start_thread (in /lib64/libpthread-2.32.so)
==9986==    by 0x4ACE1EE: clone (in /lib64/libc-2.32.so)
==9986== 
==9986== LEAK SUMMARY:
==9986==    definitely lost: 176 bytes in 2 blocks
==9986==    indirectly lost: 64 bytes in 2 blocks
==9986==      possibly lost: 0 bytes in 0 blocks
==9986==    still reachable: 0 bytes in 0 blocks
==9986==         suppressed: 0 bytes in 0 blocks
==9986== 
==9986== For lists of detected and suppressed errors, rerun with: -s
==9986== ERROR SUMMARY: 2 errors from 2 contexts (suppressed: 0 from 0)

-------------------------------------------------------------------------------
0000-0067 intermittent segfault - after "net_send_data(): source tree built"
-------------------------------------------------------------------------------
0000-0066 intermittent segfault - possibly in net_send_tree()
-------------------------------------------------------------------------------
rare timeout (cancelling send thread in 0027) - not serious, but annoying
-------------------------------------------------------------------------------
BLAKE3 hashing broken
tests 0046, 0060, and 0065 fail when librecast is build with BLAKE3
-------------------------------------------------------------------------------
intermittent segfault in 0027
after net_send_data(): source tree built
-------------------------------------------------------------------------------
make clangtest / make %clang - vector tests fail
-------------------------------------------------------------------------------
==18660== Conditional jump or move depends on uninitialised value(s)
==18660==    at 0x10DD2D: mld_address_record (mld.c:550)
==18660==    by 0x10DE6F: mld_listen_report (mld.c:579)
==18660==    by 0x10DEBD: mld_msg_handle (mld.c:587)
==18660==    by 0x10E167: mld_listen (mld.c:630)
==18660==    by 0x10E1E0: mld_listen_job (mld.c:640)
==18660==    by 0x10BA89: job_seek (job.c:84)
==18660==    by 0x4A04F5D: start_thread (in /lib64/libpthread-2.32.so)
==18660==    by 0x4B162BE: clone (in /lib64/libc-2.32.so)
This was running the server in MLD mode:
sudo valgrind src/lcsync -v --mld ~/media/dnapizza.jpg
-------------------------------------------------------------------------------
Sometimes in non-MLD node, network syncing does not work first time. A second
run is required for the checksums to match.
-------------------------------------------------------------------------------
0061 intermittent failure
0:pkts received=0 (joined)
intermittent, but quite frequent (happens more often than not)
also sometimes just blocks and doesnt complete
-------------------------------------------------------------------------------
0000-0060  net_job_send_tree() - MLD trigger
pkts received=66 (parted) FAIL
intermittent
-------------------------------------------------------------------------------
0060 pkts received=1 (joined) - Address already in use
despite SO_REUSEADDR
intermittent, but quite frequent
-------------------------------------------------------------------------------
0058 intermittently fails to recv msgs - timing?
-------------------------------------------------------------------------------
0000-0062  MLD filter testing - joining via multicast
	mld_filter_grp_cmp() - added (0)
	0: timer set to 0
	mld_filter_grp_cmp() - before part (0)                           FAIL

intermittent, possibly timing - seems to pass when run separately to other
tests.
-------------------------------------------------------------------------------
Ubuntu 16.04 LTS - segfault when serving files in --mld mode

works when not in mld mode

bacs@graupius:~/lcsync$ lcsync -v --mld src/lcsync
1551: loglevel=127
1574: blocksize=1024
1582: channels=8
1590: net_send('src/lcsync')
1597: mapping src: src/lcsync
1635: net_send_data()
1665: creating 9 threads
3040: net_send_data(): source tree built
Segmentation fault (core dumped)

-------------------------------------------------------------------------------
test 0027 requires bsd/md5.h, which Ubuntu 20.04 doesn't have, at least not
there.  Remove dependency.  Use hash function from librecast.
-------------------------------------------------------------------------------
test 0035 (check mode)
net.c:495 (again)
Syscall param sendmsg(msg.msg_iov[1]) points to unaddressable byte(s)
probably caused by a bug in the multi-channel sending code
-------------------------------------------------------------------------------
net_send_block() - works without offset?  Works with ptr increment, but not
offset?  Something fishy here.  Needs better tests - are we checking all bytes
in a multi-packet block?
-------------------------------------------------------------------------------
test 0035 (intermittent):
"Unexpected error 9 on netlink descriptor 0."
possibly in net_recv_tree()
-------------------------------------------------------------------------------
cap tests are executing as root
-------------------------------------------------------------------------------
SIGINT (ctrl-c) when running in net recv mode and recv is block interupts recv()
which generates an error, followed by segfault:
$ lcsync dnapizza.jpg /tmp/dnapizza.jpg
Operation not permitted
Bridge creation failed
ioctl (TUNSETIFF) failed: Operation not permitted
TAP creation failed
^Crecv(): Interrupted system call
Segmentation fault
-------------------------------------------------------------------------------
possibly related to above...
1111011111111111111111111111111111111111111111111111111111111111
1111111111111111111111111111111111111111111111111111111111111111
1111111111111111111111111111111111111111111111111111111111111111
1111111111111111111111111111111111111111111111111111111111111111
Multicast join failed
1111111111111111111111111111111111111111111111111111111111111111
1000000000000000000000000000000000000000000000000000000000000000
recv(): Bad file descriptor
Multicast leave failed
^C^C^C

lcsync listener not stopping
-------------------------------------------------------------------------------
SIGINT does not stop server from sending when blocked in MLD mode
SIGTERM works
-------------------------------------------------------------------------------
intermittent fail in 0062
mld_filter_grp_cmp() - false (1241374768)
integer overflow not possible, so probably writing where we shouldn't
-------------------------------------------------------------------------------
