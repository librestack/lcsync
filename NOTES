let's consider how we might call the program
* lcsync ./src ./dst
* lcsync ./src
* lcsync netsrc
* lcsync --hex
* lcsync --chunksz=512 ./src ./dst
* lcsync --seek 4242 --count=12 -- --something--  # file has leading dashes
* lcsync -  # serve file from stdin
* lcsync --port 4242 ./src
* lcsync ./localsrc netgroupalias
* lcsync ./localsrc "a long group name"

## syncing

We're syncing a subtree per channel.

Each channel therefore has a number of blocks.

Each block may span more than one datagram.

We need to write several blocks simultaneously.

We keep a bitmap per block. This is more effective than tracking bytes received
as we know when we have received a completed block and can then check the hash.

Blocks therfore need to be split into datagrams in a predictable way so that the
client can produce the bitmap.

Some numbers:

A file of size 2.1GB (2147483647 == INT_MAX bytes) splits into 524,287 x 4096
byte pages.

Spread across 8 channels (one per CPU core on my laptop...), that's 65,535
pages/chennel.

With an MTU of 1194 bytes (1500 - overhead), each block will take 4 x datagrams
to copy (3x 1194 bytes + 1 x 514 bytes).

In this case the bitmap for the block is 4 bits (a nibble).
ie.
bytes/channel  268,435,456
blocks/channel	    65,535

The same file with the same block size, spread over 128 channels:
bytes/channel	16,777,216
blocks/channel	     4,096
