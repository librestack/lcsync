--------------------------------------------------------------------------------
send MLD info with notification
eg. interface and address.  Basically the contents of struct in6_pktinfo
--------------------------------------------------------------------------------
* test / support multiple interfaces

sending needs to be triggered by a join on a specific interface.  We don't want
to block for a join on each interface, but only fire up our threads when there
is a join.  Dispatcher loop at line 663 of net.c

But first, lets write some more mld_* callbacks etc.
Can we get what we want from mld_notify()?

TODO: need a way to send in librecast on a specific interface ie.
	setsockopt(sock, IPPROTO_IPV6, IPV6_MULTICAST_IF, &i, sizeof(i)
lc_msg_send() presently uses tap or default (0)

--------------------------------------------------------------------------------
how do we handle timer expiry as an event?  Do we bother?  Probably not.
--------------------------------------------------------------------------------

FIXME - set timer low on part
FIXME - send listner query
FIXME - expire records properly

blocking mode for small number of files
otherwise start new job for each subscribe notification (requires file index)
* net_job_send_tree() exit if --mld mode and no one listening
* check subscription on each round

MLD timer stop ticking when all zero
MLD timer start ticking when reset

See 7.2.  MLD State Maintained by Multicast Routers of RFC 3810:
	  https://tools.ietf.org/html/rfc3810#section-7.2

TODO: add src arg to mld_filter_grp_*()

* more work todo in test 0054, testing mld_address_record() with different combos

--------------------------------------------------------------------------------

* subscribe to ALL joins for all channels

* subscribe to notifications for mld events
int mld_subscribe(struct in6_addr addr, int iface);

* blocking call for ALL mld events - mld_recvmsg()

* set a watch for MLD events.  Call f() with arg when event of type is
detected for group addr on iface.  If addr is NULL, trigger is set for all groups
if type is 0, trigger is set for all event types.
if iface is 0, the default interface is used

* callback to f() when MLD event detected. function must have specific
signature which accepts the info need to pass.  Pass all MLD info we can get
our hands on
int mld_watch(struct in6_addr *addr, int iface, int event, void*(*f)(void *TODO-FIXME));

* trigger callback f() with arg when MLD event detected:
int mld_trigger(struct in6_addr *addr, int iface, int event, void*(*f)(void *), void *arg);

* on mld event, queue job:
int mld_job(struct in6_addr *addr, int iface, int event, void*(*f)(void *), void *arg);

* on mld event, set sem:
int mld_wait(sem_t *sem); // FIXME - need more args as above
int mld_post(sem_t *sem);

* how do I cancel an event?  Return a handle */
* need a mld_cancel_watch(mld_watch_t) function
