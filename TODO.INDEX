--------------------------------------------------------------------------------
When sending a single file, we have an mtree with a bunch of blocks.  This isn't
a well-ordered index, but we could in theory search it for a hash and find the
relevant subtree.  We know the depth, so we only need to search a single level.

We also have the alias and root hash for the mtree channel.

When an MLD trigger arrives, we will know the requested hash, and the interface to
send on.

Prior to blocking, we need to build an index of hash -> node so we can look up
any given hash and start sending immediately.  Or we just search the level.  For
a single file, this is probably the fastest (and certainly simplest) method.

For more than one file the index starts to look more attractive.  Storing this
in a B+ tree would give O(log n) searches.  A hashmap yields O(1).

An index of multiple files needs to index a hash to a file (mtree) and block
number.  ie. we can look up any hash and find its mtree and block number.

[blockhash] => [roothash][block]

We also want to index aliases for files to their root hash.

[alias] => [roothash]

This could be two lmdb databases.

Where to store the mtrees?  They are written into mmaps, so these can just be
flushed to disk.  A directory of mtrees named after their root hashes, and two
named lmdb databases.

A request for an alias is a request to send the mtree.

A request for a hash is a request for that subtree.

The greater the depth of tree we allow requests at, the more control the
receiver has, at the cost of scalability due to the extra channels, and the
lower likelyhood of simultaneous requests for the same data.

--------------------------------------------------------------------------------
TODO index a directory of files

--------------------------------------------------------------------------------
